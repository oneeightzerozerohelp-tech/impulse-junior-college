<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Impulse Bus Rush</title>
<style>
  body { margin:0; overflow:hidden; font-family:Poppins,sans-serif; text-align:center; color:white; user-select:none; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; touch-action:manipulation; }
  #startScreen {
    position:fixed; width:100%; height:100%; background:#001d3d;
    display:flex; flex-direction:column; justify-content:center; align-items:center;
  }
  #startScreen img { width:140px; margin-bottom:10px; }
  button {
    padding:14px 30px; font-size:20px; font-weight:bold;
    background:#00b4ff; border:none; border-radius:10px; cursor:pointer;
    touch-action:manipulation; -webkit-tap-highlight-color:transparent;
  }
  canvas { display:none; }
  #controls { display:none; position:fixed; bottom:25px; width:100%; justify-content:center; gap:50px; }
  .btn {
    width:70px; height:70px; background:black;
    border:2px solid white; border-radius:50%; font-size:26px; color:white; opacity:0.8;
    touch-action:manipulation; -webkit-tap-highlight-color:transparent;
  }
  #winScreen {
    display:none; position:fixed; width:100%; height:100%; top:0; left:0;
    background:black; flex-direction:column; justify-content:center; align-items:center;
  }
  #winScreen img { width:100%; height:100%; object-fit:cover; position:absolute; top:0; left:0; opacity:0.5; }
  #winContent { position:relative; z-index:2; }
</style>
</head>
<body>

<div id="startScreen">
  <img src="html/logo.png" alt="College Logo">
  <h1>Impulse Bus Rush</h1>
  <button onclick="startGame()">Start Game</button>
</div>

<canvas id="gameCanvas"></canvas>

<div id="controls">
  <button class="btn" id="upBtn">â†‘</button>
  <button class="btn" id="downBtn">â†“</button>
</div>

<div id="winScreen">
  <img src="html/sports.jpg" alt="Sports Background">
  <div id="winContent">
    <h2>You reached college on time! ðŸŽ‰</h2>
    <p>Your Score: <span id="finalScore">0</span></p>
    <button onclick="location.reload()">Play Again</button>
  </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const controls = document.getElementById("controls");
const winScreen = document.getElementById("winScreen");

// increase player render size slightly so the bus appears a bit larger
const player = { x:30, y:0, w:132, h:88, dy:0 };
// Fallback padding if we can't compute a precise hitbox from the image
const PLAYER_HIT_PADDING_X = 18; // shrink hitbox horizontally
const PLAYER_HIT_PADDING_Y = 10; // shrink hitbox vertically

// Will be set to a tight hitbox computed from `bus.png` (in player pixels)
let BUS_HIT = null; // { offsetX, offsetY, w, h }

// Toggle to visualize hitboxes during gameplay (helpful for debugging collisions)
// Set to false for normal play so debug hitboxes are not shown.
const SHOW_HITBOX = false;
// Brief invulnerability at start to avoid instant deaths
const INVULN_MS = 1500; // milliseconds of grace after starting
let invulnerableUntil = 0;

// Prevent obstacles from spawning immediately at game start
let spawnAllowedAfter = 0;

let score = 0;
let gameActive = false;
let distance = 0;
let winDistance = 1500;
let obstacles = [];
let obstacleSpawnRate = 100;

// Preload assets and disable start until done
const startBtn = document.querySelector('#startScreen button');
startBtn.disabled = true;
startBtn.textContent = 'Loading assets...';

const assets = [
  {name:'bus', src:'html/bus.png', img:new Image()},
  {name:'bg', src:'html/classroom.jpg', img:new Image()},
  {name:'logo', src:'html/logo.png', img:new Image()},
  {name:'sports', src:'html/sports.jpg', img:new Image()},
  {name:'book', src:'html/book.jpg', img:new Image()}
];

let assetsLoaded = 0;
let assetsFailed = 0;
const totalAssets = assets.length;

assets.forEach(a=>{
  a.img.onload = ()=>{ assetsLoaded++; checkAssets(); };
  a.img.onerror = ()=>{ assetsFailed++; console.warn('Asset failed:', a.src); checkAssets(); };
  a.img.src = a.src;
});

function checkAssets(){
  if(assetsLoaded + assetsFailed === totalAssets){
    startBtn.disabled = false;
    startBtn.textContent = assetsFailed ? `Start (${assetsFailed} missing)` : 'Start Game';
    if(assetsFailed) console.warn('Some assets failed to load. Check paths in the html/ folder.');
    // compute tight hitbox for the bus sprite (scaled to `player.w`/`player.h`)
    try {
      computeBusHitbox();
    } catch(e) { console.warn('Hitbox computation failed:', e); }
  }
}

// Fallback if assets take too long
setTimeout(() => {
  if(startBtn.disabled) {
    startBtn.disabled = false;
    startBtn.textContent = 'Start Game (timeout)';
  }
}, 5000);

// Use preloaded images
const busImg = assets[0].img;
const bgImg = assets[1].img;
const bookImg = assets[4].img;

function startGame() {
  document.getElementById("startScreen").style.display="none";
  canvas.style.display="block";
  controls.style.display="block";
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  // place player near the bottom so initial obstacles don't overlap immediately
  player.y = Math.max(0, canvas.height - player.h - 20);
  player.dy = 0;
  gameActive = true;
  obstacles = [];
  distance = 0;
  score = 0;
  invulnerableUntil = performance.now() + INVULN_MS;
  // disallow obstacle spawns until after the invulnerability window
  spawnAllowedAfter = invulnerableUntil + 100;
  console.log('Player invulnerable until', invulnerableUntil);
  loop();
}

function update() {
  if(!gameActive) return;
  player.y += player.dy;
  player.y = Math.max(0, Math.min(canvas.height-player.h, player.y));
  distance += 5;
  score = Math.floor(distance / 10);

  // Spawn obstacles (disabled briefly after start to avoid instant overlaps)
  // Tuned for fair difficulty: moderate spawn chance, size variance,
  // occasional faster obstacles, and a cap on simultaneous obstacles.
  const MIN_OBSTACLE_GAP = 280; // average pixels between consecutive spawns
  const GAP_VARIANCE = 80; // randomize the gap so patterns feel organic
  const SPAWN_CHANCE = 0.012; // moderate probability per frame to attempt spawn
  const OBSTACLE_MIN_SIZE = 60;
  const OBSTACLE_MAX_SIZE = 100;
  const OBSTACLE_BASE_SPEED = 4;
  const FAST_OBSTACLE_CHANCE = 0.16; // occasional faster obstacle
  const MAX_SIMULTANEOUS = 3; // limit how many obstacles can be onscreen

  if(performance.now() >= spawnAllowedAfter && Math.random() < SPAWN_CHANCE) {
    if(obstacles.length >= MAX_SIMULTANEOUS) {
      // too many obstacles already; skip this spawn attempt
    } else {
      const last = obstacles.length ? obstacles[obstacles.length - 1] : null;
      const gap = MIN_OBSTACLE_GAP + (Math.random() - 0.5) * GAP_VARIANCE;
      // allow spawn only if there is no recent obstacle close to spawn edge
      if(!last || last.x <= canvas.width - gap) {
        const size = Math.round(OBSTACLE_MIN_SIZE + Math.random() * (OBSTACLE_MAX_SIZE - OBSTACLE_MIN_SIZE));
        // occasional faster obstacle for variety/challenge
        const speed = OBSTACLE_BASE_SPEED + (Math.random() < FAST_OBSTACLE_CHANCE ? 1 + Math.random()*1.5 : Math.random()*0.6);
        obstacles.push({
          x: canvas.width,
          y: Math.random() * Math.max(0, (canvas.height - size)),
          w: size,
          h: size,
          speed: speed
        });
      }
    }
  }

  // Update obstacles
  for(let i = obstacles.length - 1; i >= 0; i--) {
    obstacles[i].x -= obstacles[i].speed;
    
    // Remove off-screen obstacles
    if(obstacles[i].x < -obstacles[i].w) {
      obstacles.splice(i, 1);
      continue;
    }

    // Collision detection using a slightly smaller player hitbox
    // compute player hitbox: prefer tight BUS_HIT if available, otherwise use padding
    let playerHitbox;
    if(BUS_HIT) {
      playerHitbox = {
        x: player.x + BUS_HIT.offsetX,
        y: player.y + BUS_HIT.offsetY,
        w: BUS_HIT.w,
        h: BUS_HIT.h
      };
    } else {
      playerHitbox = {
        x: player.x + PLAYER_HIT_PADDING_X,
        y: player.y + PLAYER_HIT_PADDING_Y,
        w: Math.max(0, player.w - PLAYER_HIT_PADDING_X * 2),
        h: Math.max(0, player.h - PLAYER_HIT_PADDING_Y * 2)
      };
    }

    // Skip collision detection while player has start invulnerability
    if(performance.now() < invulnerableUntil) {
      // still update obstacles but don't trigger death
    } else if(checkCollision(playerHitbox, obstacles[i])) {
      console.warn('Collision detected between', playerHitbox, obstacles[i]);
      gameActive = false;
      return;
    }
  }

  // Removed automatic win at a fixed distance so the game continues
  // until the player actually hits an obstacle. This prevents the score
  // from stopping at 150 due to the previous `winDistance` check.
  // if(distance >= winDistance) {
  //   gameActive = false;
  //   document.getElementById("finalScore").innerText = score;
  //   winScreen.style.display="flex";
  // }
}

function draw() {
  if(!gameActive) {
    // Display game over screen
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font="36px Poppins";
    ctx.fillStyle = "red";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER! You hit an obstacle!", canvas.width/2, canvas.height/2);
    ctx.font="20px Poppins";
    ctx.fillText("Score: " + score, canvas.width/2, canvas.height/2 + 50);
    ctx.textAlign = "left";
    return;
  }
  
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
  
  // Draw obstacles
  for(let obs of obstacles) {
    if(bookImg.complete) {
      ctx.drawImage(bookImg, obs.x, obs.y, obs.w, obs.h);
    } else {
      ctx.fillStyle = "#ff4444";
      ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
      ctx.strokeStyle = "#ff0000";
      ctx.lineWidth = 2;
      ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
    }
  }
  
  ctx.drawImage(busImg, player.x, player.y, player.w, player.h);

  // Draw hitboxes when debugging is enabled
  if(SHOW_HITBOX) {
    let playerHitbox;
    if(BUS_HIT) {
      playerHitbox = {
        x: player.x + BUS_HIT.offsetX,
        y: player.y + BUS_HIT.offsetY,
        w: BUS_HIT.w,
        h: BUS_HIT.h
      };
    } else {
      playerHitbox = {
        x: player.x + PLAYER_HIT_PADDING_X,
        y: player.y + PLAYER_HIT_PADDING_Y,
        w: Math.max(0, player.w - PLAYER_HIT_PADDING_X * 2),
        h: Math.max(0, player.h - PLAYER_HIT_PADDING_Y * 2)
      };
    }

    ctx.save();
    ctx.strokeStyle = 'lime';
    ctx.lineWidth = 2;
    ctx.strokeRect(playerHitbox.x, playerHitbox.y, playerHitbox.w, playerHitbox.h);

    // Overlay obstacle hitboxes clearly
    ctx.strokeStyle = 'rgba(255,255,0,0.9)';
    ctx.lineWidth = 2;
    for(let obs of obstacles) {
      ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
    }
    ctx.restore();
  }
  ctx.font="18px Poppins";
  ctx.fillStyle = "white";
  ctx.fillText("Score: "+score, 20,40);
}

function loop() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(bgImg.complete) ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
  else ctx.fillStyle = '#001d3d', ctx.fillRect(0,0,canvas.width,canvas.height);

  if(gameActive) {
    if(busImg.complete) ctx.drawImage(busImg, player.x, player.y, player.w, player.h);
    ctx.font="18px Poppins, sans-serif";
    ctx.fillStyle = "white";
    ctx.fillText("Score: "+score, 20,40);
    
    // advance game state and render
    update();
  }
  
  draw();
  requestAnimationFrame(loop);
}

// keep canvas sized to window
function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
// ensure initial size
resizeCanvas();

// MOBILE CONTROLS
const upBtn = document.getElementById("upBtn");
const downBtn = document.getElementById("downBtn");
if(upBtn && downBtn){
  upBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); player.dy = -6; }, {passive:false});
  downBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); player.dy = 6; }, {passive:false});
  upBtn.addEventListener("touchend", (e)=>{ e.preventDefault(); player.dy = 0; }, {passive:false});
  downBtn.addEventListener("touchend", (e)=>{ e.preventDefault(); player.dy = 0; }, {passive:false});
  // Also handle mouse for desktop testing
  upBtn.addEventListener("mousedown", ()=> player.dy = -6);
  downBtn.addEventListener("mousedown", ()=> player.dy = 6);
  upBtn.addEventListener("mouseup", ()=> player.dy = 0);
  downBtn.addEventListener("mouseup", ()=> player.dy = 0);
}

// KEYBOARD CONTROLS (Arrow keys)
const keysPressed = {};
window.addEventListener('keydown', (e) => {
  keysPressed[e.key] = true;
  if(e.key === 'ArrowUp') {
    player.dy = -6;
    e.preventDefault();
  }
  if(e.key === 'ArrowDown') {
    player.dy = 6;
    e.preventDefault();
  }
});

window.addEventListener('keyup', (e) => {
  keysPressed[e.key] = false;
  if(e.key === 'ArrowUp' || e.key === 'ArrowDown') {
    player.dy = 0;
    e.preventDefault();
  }
});

// Collision detection function
function checkCollision(rect1, rect2) {
  // Only check collision if obstacle is actually on screen
  if(rect2.x + rect2.w < 0 || rect2.x > canvas.width) return false;
  
  return rect1.x < rect2.x + rect2.w &&
         rect1.x + rect1.w > rect2.x &&
         rect1.y < rect2.y + rect2.h &&
         rect1.y + rect1.h > rect2.y;
}

// Compute a tight hitbox for the bus image by scanning alpha pixels.
function computeBusHitbox(){
  if(!busImg || !busImg.complete) return;
  // draw the bus into an offscreen canvas at the same size we render it
  const off = document.createElement('canvas');
  off.width = player.w;
  off.height = player.h;
  const octx = off.getContext('2d');
  octx.clearRect(0,0,off.width,off.height);
  octx.drawImage(busImg, 0, 0, off.width, off.height);
  let data;
  try { data = octx.getImageData(0,0,off.width,off.height).data; }
  catch(e){ console.warn('Could not read image data for hitbox (CORS or tainting):', e); BUS_HIT = null; return; }

  let minX = off.width, minY = off.height, maxX = -1, maxY = -1;
  for(let y=0;y<off.height;y++){
    for(let x=0;x<off.width;x++){
      const idx = (y*off.width + x)*4;
      const alpha = data[idx+3];
      if(alpha > 10){ // consider pixel opaque
        if(x < minX) minX = x;
        if(y < minY) minY = y;
        if(x > maxX) maxX = x;
        if(y > maxY) maxY = y;
      }
    }
  }
  if(maxX >= minX && maxY >= minY){
    BUS_HIT = { offsetX: minX, offsetY: minY, w: maxX - minX + 1, h: maxY - minY + 1 };
    console.log('Computed bus hitbox:', BUS_HIT);
  } else {
    BUS_HIT = null; // fallback to padding
    console.log('No opaque pixels found when computing bus hitbox; using fallback padding.');
  }
}

// Prevent accidental scrolling on mobile
window.addEventListener('touchmove', (e) => {
  if(e.target === canvas) e.preventDefault();
}, {passive:false});

// Handle orientation change on mobile
window.addEventListener('orientationchange', () => {
  setTimeout(resizeCanvas, 100);
});

</script>

</body>
</html>
